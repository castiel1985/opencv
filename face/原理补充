cany 边缘检测
(1)噪声去除  ： 5*5的高斯滤波器

（2）计算图像梯度:使用 sobel算子计算水平方向和垂直方向的一阶导数
得到梯度方向 ：垂直，水平，两个对角线

（3）对每一个像素检查，去除非边界上的点，（这个点是不是周围具有相同梯度方向的点中最大的）
（4）确定哪些边界才是真正的边界：设定两个阕值 minval maxval



图像金字塔:
cv2.pyrUp()  从一个高分辨率大尺寸向上构建一个金字塔
cv2.pyrUp()   从一个低分辩率小尺寸的图像向下构建一个金字塔




轮廓：
查找轮廓：
cv2.findContours（）
cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

cv2.RETR_TREE 会返回所有轮廓，并且创建一个完整的组织结构列表
cv2.CHAIN_APPROX_SIMPLE  只是存储几个关键点位
cv2.CHAIN_APPROX_NONE   存储所有点位



直方图：
cv2.calcHist()

cv2.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]])
1. images: 原图像 图像格式为 uint8 或 float32 。当传入函数时应用中括号 [] 括 来 例如 [img]。
2. channels: 灰度是0，彩色的话 [0] [1] [2] 对应 B G R
3. mask: 掩模图像。如果要统计整幅图像就设置为 none
4. histSize:BIN 的数目。也应 用中括号括 【256】
5. ranges: 像素值范围 【0，256】

直方图均衡化（一维）:  只考虑灰度
使得一幅图像的像素点值从密集的分布转向广泛的分布的拉伸过程。
结果：改变图片的对比度,但是会丢失好多信息，

自适应直方图均衡化：将整幅图像分成很多小块，默认是（8*8），然后对这些小块进行直方图均衡。（有噪声的化，噪声会被放大）最后，使用双线性差值进行对
小块缝合。



2D直方图： 考虑 颜色Hue,饱和度Saturation
（1)先将图像的颜色空间从BGR转为HSV
（2）使用差cv2.calcHist()


直方图反向投影：（用作图像分割）
输出图像中像素值越高（越白）的点越可能代表我们需要搜索的目标。
cv2.calcBackProject()



图像变换：
傅里叶变换：用来分析不同滤波器的频率特性。
边界和噪声点再图像中变化非常大，被称为高频分量，没有的则称为低频分量。
cv2.dft()  cv2.idft()
(1)先转化为 float32
(2)调用 cv2.dft
(3)公式操作。
傅里变换可以将一幅图片分解为正弦和余弦两个分量，换而言之，他可以将一幅图像从其空间域（spatial domain）转换为频域（frequency domain）。
这种变换的思想是任何函数可以很精确的接近无穷个sin()函数和cos()函数的和。傅里叶变换提供了这种方法来达到这种效果。

注明：拉普拉斯算子是高通滤波器，Sobel 是 HPF

LPF 将图像的高频部分去除，实际就是对图像模糊操作。



模板匹配：
在一副大图中搜寻查找模板图像位置的方法
cv2.matchTemplate()


风水岭算法：   对微弱边缘具有良好的响应，但是图像的噪声和表面细微的灰度变化都会造成过度分割的情况。
(1)图像灰度化，滤波，Canny边缘检测
(2)查找轮廓，并把轮廓信息按照不同的编号绘制到watershed的第二个入参 merrkers上，相当于标记注水点
(3)watershed分水岭算法
(4)绘制分割出来的区域，或者和原始图像融合下，取得更好效果。
避免过度分割：
1）去除无关边缘信息
2）修改梯度函数，对梯度图像进行阕值处理。


grabcut 算法：




